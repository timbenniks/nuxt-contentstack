---
title: Live Preview
description: Enable real-time content editing with Contentstack's Live Preview and Visual Builder integration for seamless content management workflows.
navigation:
  icon: i-lucide-eye
---

Live Preview is one of the most powerful features of Nuxt Contentstack, enabling real-time content editing and visual building capabilities. Content creators can see their changes instantly without page refreshes, creating a seamless editing experience.

## Overview

Live Preview consists of several integrated features:

- **Real-time Updates**: See content changes instantly without page refreshes
- **Visual Builder**: Edit content directly on the page with visual editing tools
- **Edit Buttons**: Quick access to editing interfaces
- **Editable Tags**: Visual indicators for editable content areas
- **Preview Modes**: Switch between builder and preview modes

## Quick Setup

### 1. Enable Live Preview

Configure live preview in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['nuxt-contentstack'],
  
  'nuxt-contentstack': {
    // Core configuration
    apiKey: process.env.NUXT_CONTENTSTACK_API_KEY,
    deliveryToken: process.env.NUXT_CONTENTSTACK_DELIVERY_TOKEN,
    environment: 'preview', // Use preview environment
    
    // Live Preview configuration
    livePreview: {
      enable: true,
      previewToken: process.env.NUXT_CONTENTSTACK_PREVIEW_TOKEN,
      editableTags: true,
      editButton: true,
      mode: 'builder'
    }
  }
})
```

### 2. Environment Variables

Add your preview token to environment variables:

```bash [.env]
NUXT_CONTENTSTACK_API_KEY=your_api_key
NUXT_CONTENTSTACK_DELIVERY_TOKEN=your_delivery_token
NUXT_CONTENTSTACK_PREVIEW_TOKEN=your_preview_token
NUXT_CONTENTSTACK_ENVIRONMENT=preview
```

::callout{icon="i-lucide-key"}
**Preview Token**: Find your preview token in Contentstack under Settings → Tokens → Preview Tokens.
::

### 3. Update Your Components

Your existing composables automatically support live preview:

```vue [pages/[...slug].vue]
<script setup>
const route = useRoute()
const path = `/${route.params.slug?.join('/') || ''}`

// Automatically supports live preview
const { data: page, refresh } = await useGetEntryByUrl({
  contentTypeUid: 'page',
  url: path,
  referenceFieldPath: ['components', 'seo'],
  jsonRtePath: ['content']
})

if (!page.value) {
  throw createError({ statusCode: 404, statusMessage: 'Page Not Found' })
}
</script>

<template>
  <main v-if="page">
    <h1>{{ page.title }}</h1>
    <div v-html="page.content"></div>
    
    <!-- Components with live preview support -->
    <component 
      v-for="comp in page.components" 
      :key="comp.uid"
      :is="comp._content_type_uid"
      v-bind="comp"
    />
  </main>
</template>
```

## Configuration Options

### Basic Configuration

```ts
livePreview: {
  enable: true,                    // Enable/disable live preview
  previewToken: 'your_token',      // Required preview token
  editableTags: true,              // Show editable content indicators
  editButton: true,                // Show edit button
  mode: 'builder',                 // 'builder' or 'preview'
  ssr: false                       // Server-side rendering mode
}
```

### Advanced Edit Button Configuration

Customize the edit button appearance and behavior:

```ts
livePreview: {
  enable: true,
  previewToken: 'your_token',
  editButton: {
    enable: true,
    position: 'top-right',               // Button position
    exclude: [                           // Where to hide the button
      'insideLivePreviewPortal',
      'outsideLivePreviewPortal'
    ],
    includeByQueryParameter: false       // Show only with ?edit=true
  }
}
```

### Edit Button Positions

| Position | Description |
|----------|-------------|
| `top` | Top center |
| `bottom` | Bottom center |
| `left` | Left center |
| `right` | Right center |
| `top-left` | Top left corner |
| `top-right` | Top right corner |
| `top-center` | Top center |
| `bottom-left` | Bottom left corner |
| `bottom-right` | Bottom right corner |
| `bottom-center` | Bottom center |

## Live Preview Modes

### Builder Mode

Builder mode provides the full visual editing experience:

```ts
livePreview: {
  mode: 'builder'  // Full editing capabilities
}
```

**Features:**
- Visual content editing
- Drag-and-drop components
- Real-time preview
- Component property editing

### Preview Mode

Preview mode shows content updates without editing interface:

```ts
livePreview: {
  mode: 'preview'  // Preview only, no editing UI
}
```

**Features:**
- Real-time content updates
- No editing interface
- Clean preview experience
- Content validation

## Working with Components

### Basic Component Setup

Create components that work seamlessly with Live Preview:

```vue [components/content/Hero.vue]
<script setup>
// Define props based on your content type structure
defineProps<{
  title: string
  subtitle?: string
  background_image?: {
    url: string
    title: string
  }
  cta_button?: {
    text: string
    url: string
  }
}>()
</script>

<template>
  <section class="hero">
    <div 
      v-if="background_image" 
      class="hero-background"
      :style="{ backgroundImage: `url(${background_image.url})` }"
    >
      <div class="hero-content">
        <h1>{{ title }}</h1>
        <p v-if="subtitle">{{ subtitle }}</p>
        
        <NuxtLink 
          v-if="cta_button" 
          :to="cta_button.url"
          class="cta-button"
        >
          {{ cta_button.text }}
        </NuxtLink>
      </div>
    </div>
  </section>
</template>
```

### Modular Block Components

For modular content blocks, create a component mapper:

```vue [components/ContentBlocks.vue]
<script setup>
defineProps<{
  blocks: Array<{
    _content_type_uid: string
    uid: string
    [key: string]: any
  }>
}>()

// Map content type UIDs to component names
const componentMap = {
  'hero_block': 'Hero',
  'text_block': 'TextBlock',
  'image_gallery': 'ImageGallery',
  'cta_block': 'CtaBlock'
}
</script>

<template>
  <div class="content-blocks">
    <component
      v-for="block in blocks"
      :key="block.uid"
      :is="componentMap[block._content_type_uid] || 'UnknownBlock'"
      v-bind="block"
    />
  </div>
</template>
```

### Rich Text with Live Preview

Handle rich text content with live preview support:

```vue [components/RichTextContent.vue]
<script setup>
defineProps<{
  content: string
  replaceHtmlCslp?: boolean
}>()
</script>

<template>
  <div 
    class="rich-text-content"
    v-html="content"
  />
</template>

<style>
/* Ensure live preview styles don't interfere */
.rich-text-content {
  /* Your content styles */
}

/* Hide live preview markers in production */
.rich-text-content [data-cslp] {
  /* Live preview will handle these */
}
</style>
```

## Environment-Specific Configuration

### Development Setup

Enable live preview only in development:

```ts [nuxt.config.ts]
const isDev = process.env.NODE_ENV === 'development'

export default defineNuxtConfig({
  'nuxt-contentstack': {
    // ... core config
    livePreview: {
      enable: isDev,
      previewToken: process.env.NUXT_CONTENTSTACK_PREVIEW_TOKEN,
      editableTags: isDev,
      editButton: isDev
    }
  }
})
```

### Staging Environment

Configure live preview for staging environments:

```ts [nuxt.config.ts]
const isStaging = process.env.NODE_ENV === 'staging'
const enableLivePreview = process.env.ENABLE_LIVE_PREVIEW === 'true'

export default defineNuxtConfig({
  'nuxt-contentstack': {
    environment: isStaging ? 'preview' : 'production',
    livePreview: {
      enable: enableLivePreview,
      previewToken: process.env.NUXT_CONTENTSTACK_PREVIEW_TOKEN,
      editButton: {
        enable: enableLivePreview,
        includeByQueryParameter: true  // Show only with ?edit=true
      }
    }
  }
})
```

## Advanced Usage

### Manual Live Preview Integration

For advanced use cases, access the Live Preview SDK directly:

```ts [composables/useLivePreview.ts]
export const useLivePreview = () => {
  const { $contentstack } = useNuxtApp()
  
  const initLivePreview = () => {
    if (import.meta.client && $contentstack.livePreviewEnabled) {
      // Access the ContentstackLivePreview instance
      const { ContentstackLivePreview } = $contentstack
      
      // Custom live preview logic
      ContentstackLivePreview.onEntryChange((data) => {
        console.log('Entry changed:', data)
        // Custom handling
      })
    }
  }
  
  return {
    initLivePreview,
    livePreviewEnabled: $contentstack.livePreviewEnabled
  }
}
```

### Custom Edit Buttons

Create custom edit buttons for specific content areas:

```vue [components/EditableSection.vue]
<script setup>
const props = defineProps<{
  entryUid: string
  contentTypeUid: string
  title: string
}>()

const editUrl = computed(() => {
  const { $contentstack } = useNuxtApp()
  if (!$contentstack.livePreviewEnabled) return null
  
  return `https://app.contentstack.com/#!/stack/${stackApiKey}/content-type/${props.contentTypeUid}/en-us/entry/${props.entryUid}/edit`
})
</script>

<template>
  <div class="editable-section">
    <div class="content-header">
      <h2>{{ title }}</h2>
      <a 
        v-if="editUrl" 
        :href="editUrl" 
        target="_blank"
        class="edit-button"
      >
        ✏️ Edit
      </a>
    </div>
    
    <slot />
  </div>
</template>
```

## Best Practices

### Content Structure

**Modular Design:**
- Create reusable component blocks
- Use consistent naming conventions
- Structure content hierarchically

**Field Naming:**
- Use descriptive field names
- Follow camelCase or snake_case consistently
- Avoid special characters in field names

### Performance

**Efficient Updates:**
- Use specific reference paths
- Avoid deep nesting where possible
- Implement proper error boundaries

**Caching Strategy:**
- Cache static content appropriately
- Use cache invalidation for live preview
- Consider preview vs. production caching

### User Experience

**Visual Feedback:**
- Show loading states during updates
- Provide clear editing indicators
- Handle error states gracefully

**Editor Experience:**
- Provide meaningful component names
- Use descriptive help text
- Implement validation feedback

## Troubleshooting

### Common Issues

**Live Preview Not Working:**
```typescript
// Check configuration
console.log(useNuxtApp().$contentstack.livePreviewEnabled)

// Verify preview token
// Ensure environment is set to 'preview'
// Check browser console for errors
```

**Edit Button Not Appearing:**
```typescript
// Verify edit button configuration
livePreview: {
  editButton: {
    enable: true,
    position: 'top-right'
  }
}
```

**Content Not Updating:**
```typescript
// Ensure composables support refresh
const { data, refresh } = await useGetEntry(...)

// Check live preview event listeners
ContentstackLivePreview.onEntryChange(refresh)
```

### Debug Mode

Enable debug mode for detailed live preview logging:

```ts [nuxt.config.ts]
'nuxt-contentstack': {
  debug: true,
  livePreview: {
    enable: true,
    // ... other config
  }
}
```

## DevTools Integration

Monitor live preview activity in Nuxt DevTools:

1. Open browser DevTools
2. Navigate to the Contentstack tab
3. View "Live Preview Status" panel
4. Monitor real-time updates and events

The DevTools panel shows:
- Live preview connection status
- Update event counts
- Entry change timestamps
- Current preview mode

## Next Steps

::div{class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6"}
  ::card
  ---
  title: "Personalization"
  icon: "i-lucide-users"
  to: "/features/personalization"
  ---
  Learn about dynamic content personalization with Contentstack Personalize.
  ::

  ::card
  ---
  title: "DevTools"
  icon: "i-lucide-wrench"
  to: "/features/devtools"
  ---
  Explore debugging and monitoring capabilities with DevTools integration.
  ::
::

::div{class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4"}
  ::card
  ---
  title: "TypeScript Guide"
  icon: "i-lucide-code-2"
  to: "/guides/typescript"
  ---
  Set up complete type safety for your live preview components.
  ::

  ::card
  ---
  title: "Component Patterns"
  icon: "i-lucide-blocks"
  to: "/guides/component-patterns"
  ---
  Learn best practices for building modular, live preview-ready components.
  ::
::
