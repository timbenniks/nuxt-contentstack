<script setup lang="ts">
import { computed, ref, useSeoMeta, useNuxtApp } from "#imports";
import ContentstackFallbackBlock from "./ContentstackFallbackBlock.vue";
import { useGetEntryByUrl } from "../composables/useGetEntryByUrl";
import {
  extractBlocksFromPath,
  processBlock,
  getComponentForBlock as getComponent,
  getBlockProps as getProps,
  getBlockKey as getKey,
  getCslpData,
  type ContentstackBlock,
  type ProcessedBlock,
} from "./utils/blockUtils";
import { generateSeoFromEntry, type SeoMetaInput } from "./utils/seoUtils";
import { DEFAULT_BLOCKS_FIELD_PATH, DEFAULT_LOCALE } from "../constants";

// Types
interface ComponentMapping {
  [blockType: string]: any;
}

// Props
interface Props {
  /** Array of Contentstack modular blocks */
  blocks?: ContentstackBlock[];
  /** Component mapping object - maps block types to Vue components */
  componentMap?: ComponentMapping;
  /** Fallback component for unmapped block types */
  fallbackComponent?: any;
  /** CSS class for the container */
  containerClass?: string;
  /** CSS class for empty blocks (Visual Builder support) */
  emptyBlockClass?: string;
  /** Additional props to bind to the container */
  containerProps?: Record<string, any>;
  /** Show empty state when no blocks */
  showEmptyState?: boolean;
  /** CSS class for empty state */
  emptyStateClass?: string;
  /** Message to show in empty state */
  emptyStateMessage?: string;
  /** Custom key field for blocks (defaults to _metadata.uid) */
  keyField?: string;
  /** Whether to automatically extract block name from object keys */
  autoExtractBlockName?: boolean;
  /** Prefix to remove from block names when mapping components */
  blockNamePrefix?: string;

  // Entry fetching props (from useGetEntryByUrl)
  /** Content type UID for fetching entry */
  contentTypeUid?: string | undefined;
  /** URL to fetch entry by */
  url?: string | undefined;
  /** Reference field paths to include */
  referenceFieldPath?: string[];
  /** JSON RTE field paths */
  jsonRtePath?: string[];
  /** Locale for the entry */
  locale?: string;
  /** Replace HTML CSLP tags */
  replaceHtmlCslp?: boolean;
  /** Field path to extract modular blocks from (e.g., 'modular_blocks' or 'page_components') */
  blocksFieldPath?: string;
  /** SEO metadata object - passed directly to useSeoMeta */
  seoMeta?: SeoMetaInput;
  /** Auto-generate SEO metadata from fetched entry data using field mapping */
  autoSeoMeta?: boolean | Record<string, string>;
}

const props = withDefaults(defineProps<Props>(), {
  blocks: () => [],
  componentMap: () => ({}),
  fallbackComponent: ContentstackFallbackBlock,
  containerClass: "contentstack-modular-blocks",
  emptyBlockClass: "visual-builder__empty-block-parent",
  containerProps: () => ({}),
  showEmptyState: true,
  emptyStateClass: "contentstack-empty-state",
  emptyStateMessage: "No content blocks available",
  keyField: "_metadata.uid",
  autoExtractBlockName: true,
  blockNamePrefix: "",
  referenceFieldPath: () => [],
  jsonRtePath: () => [],
  locale: DEFAULT_LOCALE,
  replaceHtmlCslp: undefined,
  blocksFieldPath: DEFAULT_BLOCKS_FIELD_PATH,
  seoMeta: undefined,
  autoSeoMeta: false,
  contentTypeUid: undefined,
  url: undefined,
});

// Main logic
const shouldFetchEntry = computed(() => !!(props.contentTypeUid && props.url));

// Get editableTags setting from Contentstack context
const { editableTags } = useNuxtApp().$contentstack as {
  editableTags: boolean;
};

// Only replace CSLP when editableTags is enabled, otherwise use user preference or default to false
const shouldReplaceCslp = props.replaceHtmlCslp ?? editableTags;

// Initialize entry data
const entryData = ref(null);
const entryStatus = ref("success");
let refreshEntry = () => {};

// Expose refresh function
defineExpose({ refreshEntry: () => refreshEntry() });

// Fetch entry data if needed
if (shouldFetchEntry.value) {
  const entryResult = await useGetEntryByUrl({
    contentTypeUid: props.contentTypeUid!,
    url: props.url!,
    referenceFieldPath: props.referenceFieldPath,
    jsonRtePath: props.jsonRtePath,
    locale: props.locale,
    replaceHtmlCslp: shouldReplaceCslp,
  });

  entryData.value = entryResult.data.value as any;
  entryStatus.value = entryResult.status.value;
  refreshEntry = entryResult.refresh;

  // Handle SEO metadata
  let seoMetaToApply: SeoMetaInput = {};

  // Manual SEO metadata (takes priority)
  if (props.seoMeta) {
    seoMetaToApply = { ...seoMetaToApply, ...props.seoMeta };
  }

  // Auto-generated SEO metadata from entry data
  if (props.autoSeoMeta && entryData.value) {
    const autoGeneratedSeo = generateSeoFromEntry(
      entryData.value,
      props.autoSeoMeta
    );
    // Manual seoMeta takes priority over auto-generated
    seoMetaToApply = { ...autoGeneratedSeo, ...seoMetaToApply };
  }

  // Apply SEO metadata if we have any
  if (Object.keys(seoMetaToApply).length > 0) {
    useSeoMeta(seoMetaToApply);
  }
}

// Get blocks from either fetched entry or props
const extractedBlocks = computed((): ContentstackBlock[] => {
  if (shouldFetchEntry.value && entryData.value) {
    return extractBlocksFromPath(entryData.value, props.blocksFieldPath!);
  }
  return props.blocks || [];
});

// Computed
const processedBlocks = computed((): ProcessedBlock[] => {
  const blocksToProcess = extractedBlocks.value;
  if (!blocksToProcess || blocksToProcess.length === 0) return [];

  return blocksToProcess.map((block: ContentstackBlock) =>
    processBlock(block, {
      autoExtractBlockName: props.autoExtractBlockName,
      blockNamePrefix: props.blockNamePrefix,
      editableTags,
    })
  );
});

// Methods
function getComponentForBlock(block: ProcessedBlock): any {
  return getComponent(block, props.componentMap, props.fallbackComponent);
}

function getBlockProps(block: ProcessedBlock): Record<string, any> {
  return getProps(block, block.originalBlock._metadata);
}

function getBlockKey(block: ProcessedBlock, index: number): string {
  return getKey(block, props.keyField, index);
}
</script>

<template>
  <!-- Loading state when fetching entry -->
  <div
    v-if="shouldFetchEntry && entryStatus === 'pending'"
    :class="emptyStateClass"
  >
    <slot name="loading">
      <p>Loading content...</p>
    </slot>
  </div>

  <!-- Error state when entry fetch fails -->
  <div
    v-else-if="shouldFetchEntry && entryStatus === 'error'"
    :class="emptyStateClass"
  >
    <slot name="error">
      <p>Failed to load content. Please try again.</p>
    </slot>
  </div>

  <!-- Main content when blocks are available -->
  <section
    v-else-if="extractedBlocks && extractedBlocks.length > 0"
    :class="[
      containerClass,
      extractedBlocks.length === 0 ? emptyBlockClass : '',
    ]"
    v-bind="containerProps"
  >
    <component
      :is="getComponentForBlock(block)"
      v-for="(block, index) in processedBlocks"
      :key="getBlockKey(block, index)"
      v-bind="getBlockProps(block)"
      :data-block-type="block.name"
      :data-block-index="index"
      :data-cslp="getCslpData(block, index)"
    />
  </section>

  <!-- Fallback for empty state -->
  <div v-else-if="showEmptyState" :class="emptyStateClass">
    <slot name="empty">
      <p>{{ emptyStateMessage }}</p>
    </slot>
  </div>
</template>
